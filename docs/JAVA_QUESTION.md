# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">
POJO는 Plain Old Java Object의 준말로, 오래된 방식의 간단한 자바 오브젝트라는 의미이다.<br>
특정 기술에 의존하지 않는다는 것이 가장 큰 특징이다.<br>
스프링 프레임워크가 등장하기 이전은 자바 개발자들에게 그야말로 야생의 시대였다. 이 때 많은 개발자들은 자신이 사용하고자 하는 기술을 직접적으로 사용하는 자바 객체를 설계하였다.<br>
이런 개발 방식이 만연하자, 자바는 객체지향의 장점을 잃어가기 시작했다. 독립된 객체들 사이 자유롭게 상속을 하고 확장할 수 있다는 것이 객체지향의 대표 장점 중 하나인데, 특정 기술에 의존하는 객체들은 확장성이 매우 떨어지기 때문이다.<br>
그래서 등장한 것이 POJO의 개념이다.<br>
스프링은 JPA를 통해, 자바 객체들이 POJO의 본질을 잃지 않으면서도 새로운 기술을 도입해 사용할 수 있도록 한다.
</div>
</details>
<br>

<details>
<summary>제너릭이 무엇인가요? 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">
클래스나 메소드가 특정한 한 가지 타입만이 아닌 다양한 타입의 데이터를 사용할 수 있게 일반화시켜주는 것이 제너릭이다.<br>
컬렉션 클래스에서 제너릭을 사용하면, 해당 클래스에 여러 가지 데이터가 저장될 수 있다.<br>
예를 들어, 자바 공식 문서에서의 ArrayList를 살펴보면, ArrayList 뒤의 꺽쇠 안에 Integer나 String 등의 구체적인 데이터 타입이 아닌 E라는 문자가 들어가있다.<br>
여기서 E가 바로 제너릭의 일종이다. 제너릭을 사용했기 때문에 ArrayList 자료구조에는 다양한 요소가 저장될 수 있다.
</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">
1. 클래스 변수의 기본값<br>
2. 클래스 변수의 명시적 초기화<br>
3. 클래스 초기화 블럭<br>
4. 인스턴스 변수의 기본값<br>
5. 인스턴스 변수의 명시적 초기화<br>
6. 인스턴스 초기화 블럭<br>
7. 인스턴스 생성자
</div>
</details>
<br>

<details>
<summary>직렬화란 무엇인가요?</summary>
<div markdown="1">
직렬화는 데이터를 저장하기 위해, 혹은 다른 시스템으로 전송하기 위해 정해진 포맷으로 변환하는 일을 말한다.<br>
자바 직렬화는 기존의 객체 데이터를 byte 형태의 데이터로 변환한다.<br>
반대로, byte 형태로 변환되어있는 데이터를 다시 기존의 데이터 혹은 기존의 Object 상태로 되돌리는 것을 역직렬화라고 한다.
</div>
</details>
<br>

<details>
<summary>[예습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">
SOLID는 SRP, OCP, LSP, ISP, DIP를 가리킨다.<br><br>
1. SRP<br>
Single Responsibility Principle, 단일 책임 원칙<br>
한 클래스는 하나의 책임만 가져야 한다.<br>
그러나, 하나의 책임이라는 것의 정의는 모호하다. 어느 범위까지를 '하나'라고 할 수 있는가?<br>
이 원칙의 핵심은 '하나'의 정의를 내리는 것이 아니다.<br>
특정 클래스가 너무 많은 역할을 가지고 있어서, 혹은 너무 큰 파급효과를 가지고 있어서, 그 클래스를 변경하는 순간 프로그램의 여러 부분에서 큰일이 난다면 이 원칙을 지키지 못한 것이다.<br>
변경이 있을 때 파급효과가 적어 관리하기가 용이하다면 이 법칙을 잘 지킨 것이다.<br>
책임을 무조건 최대한 잘게 쪼개어 부여하는 게 좋은 것도 아니다. 쓸데없이 너무 조금씩의 책임을 많은 클래스에 분배하면 오히려 효율이 떨어진다.<br>
합의점을 잘 찾아서 책임을 적절히 분배해야 한다.<br><br>
2. OCP<br>
Open/Closed Principle, 개방-폐쇄 원칙<br>
소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.<br>
가장 중요하지만, 언뜻 들으면 말도 안 되는 원칙이다. 애초에 확장을 하려면 기존의 코드에 손을 대야 하는데, 어떻게 변경 없이 확장을 하라는 말인가?<br>
하지만, 스프링은 변경 없이 확장을 할 수 있게 해주는 방법을 제공한다. 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 생성자들이다.<br>
DI, IoC 컨테이너 등이 그러한 역할을 한다.<br><br>
3. LSP<br>
Liskov Substitution Principle, 리스코프 지환 원칙<br>
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.<br>
상위에서 정해놓은 사항을 하위 인스턴스가 마음대로 바꾸지 말아야 한다는 뜻이다.<br>
이 법칙을 잘 치키면 프로젝트 코드 전체에 일관성이 생기고, 사용과 관리가 편리해진다. 프로젝트에 함께 참여하는 개발자들 사이 혼선이 생기는 일도 막을 수 있다.<br><br>
4. ISP<br>
Interface Segregation Principle, 인터페이스 분리 원칙<br>
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.<br>
인터페이스 하나가 여기저기 다양한 다 쓰이게 하지 않고, 각 클라이언트별(역할별)로 각자 다른 인터페이스가 담당하게 잘 쪼개야 한다.<br>
이렇게 해야, 클라이언트 A에 관련된 변경사항이 생겨 인터페이스 A의 코드를 고치더라도 클라이언트 B에는 아무 영향이 없도록 할 수 있다.<br>
따라서 유지보수하기가 좋아진다.<br><br>
5. DIP<br>
Dependency Inversion Principle, 의존관계 역전 원칙<br>
구현체에 의존하지 않고, 인터페이스에만 의존하라는 뜻이다.<br>
이 원칙을 지키면, 전체 코드를 인터페이스에 맞추어 짜놓고, 구현제는 유연하게 갈아끼울 수 있기 때문이다.<br>
코드가 특정 구현체에 의존하게 해놓으면, 구현체가 바뀔 때마다 문제가 발생한다.<br>
</div>
</details>
<br>

<details>
<summary>[예습] DI는 무엇일까요?</summary>
<div markdown="1">
DI는 Dependency Injection의 약자이다.<br>
A라는 클래스와 B라는 인터페이스가 있다고 하자.<br>
A는 자신의 필드로서 B 인터페이스를 구현한 클래스 중 하나의 객체를 생성하여 사용한다.<br>
B 인터페이스를 구현한 클래스는 B1과 B2가 있다.<br>
A의 내부에 private final B b = new B1(...); 혹은 private final B b = new B2(...); 와 같이 생성자를 호출하여 사용할 수 있을 것이다.<br>
그러나 이렇게 하면, B1을 사용하고 있다가 B2로 갈아타고 싶을 때 A의 코드를 수정해야만 한다. 그럼 A와 B 사이의 독립성이 보장되지 않는다.<br>
이러한 문제를 해결하는 것이 DI이다. 내가 사용할 도구를 내가 직접 만들어내지 않고, 외부에서 주입받는 것이다.<br>
위의 예시의 경우, 생성자를 통째로 써주는 대신, private final B b; 라고 선언만 해둔 뒤, b 객체에 들어갈 구현체 자체는 외부에서 매개변수로 받아오는 메소드를 만들어주면 된다.<br>
이렇게 하면 A가 B의 구현체들 중 어떤 것을 쓰고 싶든지 A의 코드를 수정할 필요가 없다. A의 인스턴스를 생성해줄 때 내 마음대로 주입해주기만 하면 된다.
</div>
</details>
<br>